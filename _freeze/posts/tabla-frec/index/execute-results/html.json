{
  "hash": "1893fc92bff45669cec462894c094f1c",
  "result": {
    "markdown": "---\ntitle: \"Cómo hacer una tabla de frecuencias en R con `tidyverse`\"\nauthor: \"Juan Riera\"\ndate: 2023-01-21\nformat: html\neditor: visual\n---\n\n\nPara hacer una tabla de frecuencias, el primer paso es cargar la librería `tidyverse` y leer los datos en $R$, en este caso a partir de un archivo *CSV*.\n\nComo el `.CSV` ha sido generado desde Excel en español, los separadores son puntos y comas, y el separador de los decimales será la coma, y tendrá este aspecto èn un editor de texto básico:\n\n![CSV separado por comas en un editor de texto](2023-01-21.png)\n\nPara leer este archivo, utilizaremos la función `read_csv2()`que se adapta a este formato usado en Europa (utiizamos la función de `tidyverse`y no la función `read.csv2()`de $R$ básico)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndf <- read_csv2(\"camembert.csv\") \n```\n:::\n\n\nVamos a utilizar los *pipes* de $R$ para construir nuestra tabla paso a paso. El primer paso es seleccionar la variable de la que vamos a hacer la tabla, en este caso es $est$, el $extracto\\ seco\\ total$.\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n df |>\n  select(est)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 211 × 1\n     est\n   <dbl>\n 1  46.7\n 2  48.1\n 3  46.0\n 4  46.2\n 5  45.8\n 6  46  \n 7  44.8\n 8  45.8\n 9  47.1\n10  45.6\n# … with 201 more rows\n```\n:::\n:::\n\n\nA continuación, agrupamos los valores por intervalos. Para ello usamos la función `cut_width()` de la librería `ggplot2`, que nos permite *cortar* los valores en intervalos, definidos por el parámetro `width=`; en este caso, damos al intervalo una amplitud de $1$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(est) |>\n  mutate(est_group = cut_width(est, width = 1)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 211 × 2\n     est est_group  \n   <dbl> <fct>      \n 1  46.7 (46.5,47.5]\n 2  48.1 (47.5,48.5]\n 3  46.0 (45.5,46.5]\n 4  46.2 (45.5,46.5]\n 5  45.8 (45.5,46.5]\n 6  46   (45.5,46.5]\n 7  44.8 (44.5,45.5]\n 8  45.8 (45.5,46.5]\n 9  47.1 (46.5,47.5]\n10  45.6 (45.5,46.5]\n# … with 201 more rows\n```\n:::\n:::\n\n\nLo que hemos hecho es designar el intervalo al que pertenecen todos los valores de $est$, con la amplitud de intervalo que hemos definido mediante el parámetro elegido.\n\nEl paso siguiente es agrupar los intervalos, contando el número de veces que aparece cada uno.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(est) |>\n  mutate(est_group = cut_width(est, width = 1)) |>\n  group_by(est_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 211 × 2\n# Groups:   est_group [9]\n     est est_group  \n   <dbl> <fct>      \n 1  46.7 (46.5,47.5]\n 2  48.1 (47.5,48.5]\n 3  46.0 (45.5,46.5]\n 4  46.2 (45.5,46.5]\n 5  45.8 (45.5,46.5]\n 6  46   (45.5,46.5]\n 7  44.8 (44.5,45.5]\n 8  45.8 (45.5,46.5]\n 9  47.1 (46.5,47.5]\n10  45.6 (45.5,46.5]\n# … with 201 more rows\n```\n:::\n:::\n\n\nParece que no ha sucedido nada porque en `tidyverse`necesitamos indicar cómo vamos a utilizar la agrupación. En este caso, queremos **contar** el nímero de veces que aparece cada intervalo, lo que nos dará la **frecuencia** de valores que aparecen en ese intervalo. Para ello, usamos `summarize()`. Esta función sustituye el dataframe original por un nuevo dataframe con el resultado de la agrupación de `est_group`, creando además una nueva variable, que llamaremos $frec$ y que cuenta el número de veces que aparece cada valor de intervalo mediante la función `n()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(est) |>\n  mutate(est_group = cut_width(est, width = 1)) |>\n  group_by(est_group) |>\n  summarize (frec = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 2\n  est_group    frec\n  <fct>       <int>\n1 [42.5,43.5]     1\n2 (43.5,44.5]    12\n3 (44.5,45.5]    28\n4 (45.5,46.5]    60\n5 (46.5,47.5]    57\n6 (47.5,48.5]    33\n7 (48.5,49.5]    12\n8 (49.5,50.5]     7\n9 (52.5,53.5]     1\n```\n:::\n:::\n\n\nYa tenemos nuestra tabla de frecuencias. Sin embargo, tenemos un inconveniente, y es que la agrupación se *salta* aquellos intervalos que tienen frecuencia $cero$: no nos apararece el intervalo $(50.5,51.5]$ ni el $(51.5,52.5]$ porque no hay ningún valor en estos intervalos. Por defecto, al igual que pasa en *Excel*, los casos inexistentes (con una frecuencia de $cero$) no aparecen en la tabla de frecuencias. Pero, al contrario que en *Excel*, en $R$ sí tenemos una forma de decir que queremos que aparezcan, y es *rellenar* los casos $cero$ con el valor $0$. Utilizamos para ello la función `complete()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(est) |>\n  mutate(est_group = cut_width(est, width = 1)) |>\n  group_by(est_group) |>\n  summarize (frec = n()) |>\n  complete(est_group, fill = list(frec = 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 2\n   est_group    frec\n   <fct>       <int>\n 1 [42.5,43.5]     1\n 2 (43.5,44.5]    12\n 3 (44.5,45.5]    28\n 4 (45.5,46.5]    60\n 5 (46.5,47.5]    57\n 6 (47.5,48.5]    33\n 7 (48.5,49.5]    12\n 8 (49.5,50.5]     7\n 9 (50.5,51.5]     0\n10 (51.5,52.5]     0\n11 (52.5,53.5]     1\n```\n:::\n:::\n\n\nAhora sí está completa nuestra tabla de frecuencias.\n\nResumiendo los pasos que hemos dado,\n\n-   seleccionamos la variable de la que queremos hacer la tabla de frecuencias\n-   creamos una nueva variable con los intervalos que deseamos\n-   agrupamos los intervalos creando una nueva variable que recoge las frecuencias\n-   completamos los casos vacíos para que aparezcan con el valor $cero$\n\nSi queremos utilizar la tabla de frecuencias, podemos guardarla en una variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla_frec <- df |>\n  select(est) |>\n  mutate(est_group = cut_width(est, width = 1)) |>\n  group_by(est_group) |>\n  summarize (frec = n()) |>\n  complete(est_group, fill = list(frec = 0))\n```\n:::\n\n\nVerificamos nuestra tabla, imprimiendo la variable que hemos creado:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla_frec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 2\n   est_group    frec\n   <fct>       <int>\n 1 [42.5,43.5]     1\n 2 (43.5,44.5]    12\n 3 (44.5,45.5]    28\n 4 (45.5,46.5]    60\n 5 (46.5,47.5]    57\n 6 (47.5,48.5]    33\n 7 (48.5,49.5]    12\n 8 (49.5,50.5]     7\n 9 (50.5,51.5]     0\n10 (51.5,52.5]     0\n11 (52.5,53.5]     1\n```\n:::\n:::\n\n\nCon esta tabla de frecuencia podemos hacer un gráfico de barras\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla_frec |>\n  ggplot(aes(x=est_group, y = frec)) +\n    geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nque es equivalente a un histograma con la parametrización adecuada\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  ggplot(aes(x=est)) +\n    geom_histogram(colour=\"white\", fill=\"dodgerblue4\", binwidth = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## Otras alternativas\n\nLa elección de la función de corte nos permite agrupar los intervalos de forma ligeramente diferente. Si utiizamos como opción `cut_interval=` en vez de `cut_width=`, y utilizamos el parámetro `n=`, definiremos el número de intervalos y no la amplitud. Veamos el efecto en el diagrama de utilizar esta opción con `n = 9`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(est) |>\n  mutate(est_group = cut_interval(est, n = 9)) |>\n  group_by(est_group) |>\n  summarize (frec = n()) |>\n  complete(est_group, fill = list(frec = 0)) |>\n  ggplot(aes(x=est_group, y = frec)) +\n    geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nEl parámetro opcional `cut_interval=` también permite definir la amplitud del intervalo (no siempre es compatible con el parámetro `n=` ya que el intervalo que proporcionemos en `length=` puede no corresponderse con el número de clases que definimos con `n=`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(est) |>\n  mutate(est_group = cut_interval(est, length = 1)) |>\n  group_by(est_group) |>\n  summarize (frec = n()) |>\n  complete(est_group, fill = list(frec = 0)) |>\n  ggplot(aes(x=est_group, y = frec)) +\n    geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n### Para probar\n\nA partir del último bloque de código, encuentra la forma de obtener e imprimir la tabla de frecuencias que se obtiene con `cut_interval=`\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}